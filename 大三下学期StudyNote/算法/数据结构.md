[TOC]

# 数据结构

## hashmap和hashtable的区别

* 继承与实现的区别

  * hashmap 继承于实现了 Map 接口的 AbstractMap ；
  * hashtable 继承于实现了 Map 接口的 Dictionary（字典），由于设计上的缺陷，现在不推荐使用；

* 线程安全不同

  * HashTable的方法是同步的，HashMap是未同步，所以在多线程场合要手动同步HashMap。
  * **HashMap给出了他自己的解决并发办法，多线程需要使用HashMap建议**采用concurrent并发包下的concurrentHashMap。

* 对null的处理不同

  * HashTable不允许null值(key和value都不可以),HashMap允许null值(key和value都可以)。即 HashTable不允许null值其实在编译期不会有任何的不一样，会照样执行，只是在运行期的时候Hashtable中设置的话回出现空指针异常。 HashMap允许null值是指可以有一个或多个键所对应的值为null。（key 也可以为 null,源码中对于这种情况做出了处理，存放于 table[0] 链表的表头）当get()方法返回null值时，既可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。

* HashTable使用Enumeration（列举），HashMap使用Iterator（迭代器）。

* 扩容方式不同：HashTable中hash数组默认大小是11，增加的方式是 old\*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。根据HashMap的实现，它在每次扩容后的容量是原先的一倍。扩充结果都为2的幂次方大小。即HashMap总是使用2的幂作为哈希表的大小。这样做可以成倍提升计算Hash值的效率，为什么这么说呢？因为HashMap大小是2的幂次方，所以它使用取模计算时，可以直接使用位运算来得到结果，效率大大高于以前使用除法的效率。比如在HashMap执行增加、删除、查找键值对时，定位到哈希位置是很关键的一步，源码中是通过下面3个操作来完成这一步：1）拿到key的hashCode值；2）将hashCode的高位参与运算，重新计算hash值；3）将计算出来的hash值与(table.length - 1)进行&运算。

* 哈希值的使用：HashTable直接使用对象的hashCode，代码是这样的：

  ~~~java
  int hash = key.hashCode();

  　　int index = (hash & 0x7FFFFFFF) % tab.length;

  　　//而HashMap重新计算hash值，而且用位运算代替求模

  ~~~


## 平衡二叉树

* 参考至`<https://www.cnblogs.com/qiumingcheng/p/4738661.html>`

### 定义

*  父节点的左子树和右子树的高度之差不能大于1，也就是说不能高过1层，否则该树就失衡了，此时就要旋转节点，在

  编码时，我们可以记录当前节点的高度，比如空节点是-1，叶子节点是0，非叶子节点的height往根节点递增。

* 它的左子树和右子树都是平衡二叉树。

* 又称为AVL树，AVL树是二分搜索树

## 怎么形成平衡二叉树

* 当插入一个数据到二叉树后，如果此时破坏了平衡二叉树的结构，那么我们就需要去调整它

  ① 左左情况（左子树的左边节点）

  ![img](https://pic002.cnblogs.com/images/2012/214741/2012072218213884.png)

  我们看到，在向树中追加“节点1”的时候，根据定义我们知道这样会导致了“节点3"失衡，满足“左左情况“，此时我们就可以把失衡节点设置成根节点，然后调整它的右树即可

  ② 右右情况（右子树的右边节点）

  ![img](https://pic002.cnblogs.com/images/2012/214741/2012072218444051.png)

  同样，”节点5“满足”右右情况“，其实我们也看到，这两种情况是一种镜像，当然操作方式也大同小异，此时我们就可以把失衡节点设置成根节点，然后调整它的左书即可

   

  ③左右情况（左子树的右边节点），处理思想是将左右情况变成左左情况，然后再处理

  ![img](https://pic002.cnblogs.com/images/2012/214741/2012072219144367.png)

  从图中我们可以看到，当我们插入”节点3“时，“节点5”处失衡，注意，找到”失衡点“是非常重要的，当面对”左右情况“时，我们将失衡点的左子树进行"右右情况旋转"，然后进行”左左情况旋转“，经过这样两次的旋转就OK了，很有意思，对吧。

   

  ④右左情况(右子树的左边节点）处理思想：是将右左情况变成右右情况，然后再处理

  ![img](https://pic002.cnblogs.com/images/2012/214741/2012072219540371.png)

* 验证是否已经是平衡二叉树：中序遍历所得关键字的值序列从小到大即可（二叉排序树的性质）