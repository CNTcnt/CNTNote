[TOC]

# Java虚拟机面试

## JVM常见面试题

### 介绍下 Java 内存区域

* 要会默写

![](https://user-gold-cdn.xitu.io/2019/5/6/16a8b0a7b10d6cbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### Java 对象的创建过程

* 要会默写

![](https://user-gold-cdn.xitu.io/2019/5/6/16a8b0a7b155ea95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

类加载时机：new,getStatic,putstatic,invokestatic;反射调用时；当初始化一个父类还未初始化的对象时，初始化其父类；当虚拟机启动时，会去启动一个主类（main）



### 对象的访问定位有几种

1. 句柄方式：Java堆中将会划出一块内存来作为句柄池，reference对象存储的就是对象的句柄地址。句柄中包含了对象实例数据和类型数据的具体地址：
2. 直接指针：reference对象直接存储对象地址（此时对象地址中保存着对象对象实例和在方法区的对象类型的具体地址）

![](https://user-gold-cdn.xitu.io/2019/5/6/16a8b0a7b84e2ee4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 优缺点: 使用句柄好处是，当对象发生改变，只需要移动句柄的实例数据指针即可，而直接指针就是速度快。

* 句柄：由于reference中存储的是稳定的句柄地址，在对象被移动时（如GC过程中的对象移动），只需改变句柄中实例数据指针，而reference本身不用动。

* 直接指针：速度快，节省了一次指针定位的时间开销。HotSpot采用此方式

  

### String、StringBuilder、StringBuffer 有什么不同

* 参考答案是：String 是用 final 修饰的类，由于它的不可变性，类似拼接、裁剪字符串等，都会产生新的对象。StringBuffer 解决上面拼接对象而提供一个类，可以通过 append等方法拼接，是线程安全的，由于线程安全，效率也下降,StringBuilder 跟StringBuffer 差不多，只是去掉了线程安全，所以优先使用 StringBuilder;

* 说说String 为什么会产生新的对象？比如 String a = "1" String b = a + "2"，当执行这条指令时，会在常量池中产生一个对象指向a，而创建b时也会重新在常量池中生成b的对象；多次创建容易触发 GC，这也是为什么不建议使用 String 类去拼接的问题。

  

## Java GC机制常见面试题

### 介绍一下强引用、软引用、弱引用、虚引用

![img](https://images2015.cnblogs.com/blog/249993/201703/249993-20170306195851516-1068507269.png)

**1、强引用**

代码中普遍存在的类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

**2、软引用**

描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。

**3、弱引用**

描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉**只被**弱引用关联的对象。Java中的类WeakReference表示弱引用。

**4、虚引用**

这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。

### 谈谈final、finally、finalize 有什么不同

* 可能会疑惑为什么这个问题会归类到虚拟机的问题这里

* 解惑：final 和finally 比较好理解。首先 final 用来修饰的对象不可变；finally 则是保证重点代码一定要被执行的一种机制，一般用于 try - catch-finally 语句中。但finalize 是什么东西呢？在解释标准代码之前，又得回到GC算法中了。首先，finalize 是 Object 的一个方法，用来特定资源的回收。上面说到，当 GC Roots 不可达时，认为对象已经不再使用了，但是对象并非是非"死"不可，当 GC Roots 不可达时，系统首先会先判断 对象的 finalize 是否执行，不执行则直接回收；如果可以执行，则放在队列中，由finalize线程去执行它，如果有其他对象关联时，则判断对象不可回收，否则对象回收，finalize 执行一次，如下图：

  ![在这里插入图片描述](https://user-gold-cdn.xitu.io/2019/5/6/16a8b0a813b82ce6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 怎么判断对象死了没有

- 在**堆**里面存放着几乎所有的对象，gc 就是要收集死了的对象的内存，所以对象死还是活也需要一个标准来限制，根据标准来产生算法。

#### 引用计数算法

- 引用计数算法很简单：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加一，引用失效时就减一，当计数器为0时，则判定此对象不再被别的地方引用，可回收；

- 优点：实现简单，效率高，Python语言等还有其他就使用引用计数法进行内存管理，主流的Java虚拟机并不使用它；

- 缺点：引用计数法有一个致命的缺点，它很难解决对象之间相互引用导致内存泄漏的问题，在遍历时可能会发生这两个对象引数永远不为0，则永远不会被删除。举个例子就可以很好地说明：

  ```java
  public class MyObject{
    public Object instance = null;
    public static void testGC(){
      MyObject a = new MyObject();
      MyObject b = new MyObject();
      a.instance = b;
      b.instance = a;
      //此时 b，a 的引用计数器都为2
      a = null;
      b = null;
      //此时 b，a 的引用计数器都为1
      //此时发生 GC，虽然我们想让 a,b 对象回收内存，可是此时它们的引用计数器都不为0，所以回收内存失败；（这里是假设虚拟机使用的是引用计数法的情况）
      System.gc();
    }
  }
  ```

#### 可达性分析算法

- 既然Java虚拟机不用引用计数法，那么用什么呢？结果就是可达性算法；

- 基本思路：通过一系列称为“GC Root”的对象作为起始点，从这些结点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Root 没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达），则证明此对象是不可用的；

- 注意：JVM中并不是判断对象不可达就立即回收，**被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程**，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。

- 那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：

  (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

  (2). 方法区中的类静态属性引用的对象。

  (3). 方法区中常量引用的对象。

  (4). 本地方法栈中JNI(Native方法)引用的对象。

- 下面给出一个GCRoots的例子，如下图，为GCRoots的引用链。

  ![](https://images2015.cnblogs.com/blog/249993/201703/249993-20170302205315766-1323892362.png)

- 对于可达性分析算法而言，未到达的对象并非是“非死不可”的，若要宣判一个对象死亡，至少需要经历两次标记阶段。

  1. 如果对象在进行可达性分析后发现没有与GCRoots相连的引用链，则该对象被第一次标记并进行一次筛选，筛选条件为是否有必要执行该对象的finalize方法，若对象没有覆盖finalize方法或者该finalize方法是否已经被虚拟机执行过了，则均视作不必要执行该对象的finalize方法，即该对象将会被回收。反之，若对象覆盖了finalize方法并且该finalize方法并没有被执行过，那么，这个对象会被放置在一个叫F-Queue的队列中，之后会由虚拟机自动建立的、优先级低的Finalizer线程去执行，而虚拟机不必要等待该线程执行结束，即虚拟机只负责建立线程，其他的事情交给此线程去处理。
  2. 对F-Queue中对象进行第二次标记，如果对象在finalize方法中拯救了自己，即关联上了GCRoots引用链，如把this关键字赋值给其他变量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除，如果对象还是没有拯救自己，那就会被回收。对象的finalize方法最多被虚拟机调用一次。即只能拯救自己一次；



### 方法区会回收资源吗？

* 虽说 Java 堆 可以回收70%~95%的空间，但方法区同样可以回收一些资源，方法区主要回收两个部分**废弃常量**和**无用的类**。

  ![在这里插入图片描述](https://user-gold-cdn.xitu.io/2019/5/6/16a8b0a829fb9516?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 在方法区中进行垃圾收集的"性价比"比较低，但是再小的蚊子也是肉，也需要收集；

* 方法区的垃圾回收主要回收两部分内容：1. 废弃常量。2. 无用的类。既然进行垃圾回收，就需要判断哪些是废弃常量，哪些是无用的类。

* 如何判断废弃常量呢？以字面量回收为例，如果一个字符串“abc”已经进入常量池，但是当前系统没有任何一个String对象引用了叫做“abc”的字面量，那么，如果发生垃圾回收并且有必要时，“abc”就会被系统移出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

* 如何判断无用的类呢？需要满足以下三个条件

  1. 该类的所有实例都已经被回收，即Java堆中不存在该类的任何实例。
  2. 加载该类的ClassLoader已经被回收。
  3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

  满足以上三个条件的类可以进行垃圾回收，但是并不是无用就被回收，虚拟机提供了一些参数供我们配置。需要时查询即可；

### 垃圾回收有哪些算法，各自的特点？

![](https://user-gold-cdn.xitu.io/2019/5/6/16a8b0a81cab1770?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### Java内存分配和回收策略

- [https://blog.csdn.net/dingji_ping/article/details/51008338](https://blog.csdn.net/dingji_ping/article/details/51008338)

Java堆中各代分布![](https://img-blog.csdn.net/20160331201706716)

* **Young**（年轻代）：主要是用来存放新生的对象。对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。

- 年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（用来表示内存首次分配的区域）和两个存活区（Survivor 0 、Survivor 1）。
- 绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；
- 当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1 是空白的，两个Survivor总有一个是空白的）；
- 此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；
- 当Survivor0 也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）;
- 当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。 　　 
- **Old**（年老代）：主要存放应用程序中生命周期长的内存对象。
- 对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC 后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　　
- 可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。 　　
- 如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold 来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。
- 可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。
- **Permanent**（永久代）：是指内存的永久保存区域,也就是方法区，主要存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域. 它和和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。

## 类加载的问题

### 类加载过程

![](https://user-gold-cdn.xitu.io/2019/5/6/16a8b0a838beebcb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 说说你对类加载器的理解

* 类在加载的时候，就是通过一个全限定名去加载这个类的二进制字节流，这个是系统自动完成的。这个动作如果从外部去做，以便于我们去获取所需的类，则我们成为**类加载器**。比如通过一个路径获取到一个 class 字节码，然后通过反射，拿到相应的信息。
* 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间；即：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，不然如果就算这两个类的文件完全相同，如果由不同的类加载器加载，那么会判定这两个类不相等；

### 什么是双亲委派模型

* 它的工程流程是： 当一个类加载器收到类加载的请求，先查看这个类是否已加载过，如果还没有，它首先不会自己去尝试加载这个类，而是委派给她的父类加载器（以组合模式实现而不是继承）去完成，每一个层次的类加载器都是如此，因此所有的加载器都会传递到父加载器中；只有父加载器无法完成时，子加载器才会尝试自己去加载；

* 这里强调一点，很多人认为各个父子类加载器之间是继承关系，这里澄清一下，父子类加载器之间是组合关系，子类类加载器会含有一个parentClassLoader的对象，类加载的时候通常会按照树形结构的原则来进行，也就是说，首先是从parentClassLoader中尝试进行加载，当parent无法进行加载时，再从当前的类加载器进行加载，以此类推。JVM会保证一个类在同一个ClassLoader中只会被加载一次。

* 双亲委派模型的模型如下：

  ![类加载双亲委派模型](https://user-gold-cdn.xitu.io/2019/5/6/16a8b0a83b327d7b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 自定义类加载器：继承抽象类ClassLoader，覆写findClass方法，并在findClass 中调用defineClass 方法即可；

### 破坏双亲委派模型的情况

*  现有一个场景：如果有10个Web App应用程序部署在Tomcat 中，使用同一个 Spring 中进行组织和管理的话。可以把 Spring 放到 Tomcat 下的 Common 或 Shared 目录下让这些 Web App 共享，（即这10个 WebApp 使用一个 Spring 进行管理，如果每个 WebApp 将 Spring 存放于各个应用程序的隔离目录中，使用它，那么10个WebApp 就有10份Spring 类库要加载到 内存中，这样虚拟机的方法区就会很容易出现过度膨胀的危险），那其实只要有一份 Spring 类库让 我们的10个WebApp 进行共享即可；
* 这样又有一个问题需要解决：存放于 Tomcat 下的 Common 或 Shared 目录下的 Spring 怎么去管理 用户程序的类，因为要隔离自然要能访问到用户程序的类啊，而用户程序的类是存放于应用程序的/Webpp/WEB_INF 目录中，那么问题就转成：被 CommonCLassLoader 或 SharedClassLoader 加载的 Spring 如何访问到不在其加载范围内的用户程序呢？因为 CommonCLassLoader 或 SharedClassLoader 和其上层类加载器都没有能力加载到我们指定的用户程序，因为没有他们的路径下根本没有我们指定的用户程序。
* 根据双亲委派模型，越基础的类由越上层的类加载器进行加载，基础类之所以称为“基础”，是因为作为被用户代码调用的 API ；那么现在就有一个问题，作为基础类的 Spring 怎么去访问到 下层类加载器加载的 用户代码？？？
* 如果使用双亲委派模型根本不可能实现，因为这个模型本身就不允许，所以，我们需要破坏这个双亲委派模型。
* 为了解决这个问题，Java 设计团队破坏了双亲委派模型，引入一个：线程上下文加载器，这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser() 方法进行设置，如果创建线程时还未设置，那么这个类加载器默认就是应用程序类加载器；现在好了，有了这个线程上下文加载器，可以轻松地完成我们上面的任务，即 父类加载器请求子类加载器去完成类加载的动作，这样当然很轻松就可以轻松访问到下层类加载器加载的 用户代码；

