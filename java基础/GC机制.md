[TOC]



# GC机制

* GC：Carbage Colllection，垃圾收集，参考至《深入理解Java虚拟机》
* Java虚拟机所管理的内存包括一下几个运行时数据区域：
  * 程序计数器
  * 虚拟机栈：线程私有，生命周期和线程相同；虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧 ，用于储存局部变量表（包含对象引用），操作数栈，动态链接，方法出口等信息，每一个方法从调用直至执行完成的过程就对应着一个栈帧在虚拟机占中入栈到出栈的过程；
  * 本地方法栈：作用和虚拟机栈类似，但是本地方法栈为虚拟机使用到的Native方法服务;
  * 方法区：各个线程共享的内存区域，用于储存已被虚拟机加载的类信息，常量，静态变量
  * 堆：所有线程共享，此内存区域的唯一摸底就是存放对象实例；是垃圾收集器管理的主要区域，因此也被称为：GC堆；由于现在收集器基本采用分代收集算法，所以Java堆中细分为：新生代和老年代，（还可以再细致划分）；从内存分配角度看，线程共享的Java堆中还可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer ，TLAB）;

## gc 主要收集内存中哪些位置的的内存呢？

* 答：而程序计数器，虚拟机栈，本地方法区3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而执行进栈出栈操作，每一个栈帧分配多少内存基本已知，所以这几个区域的内存分配和回收都具备确定性，不需要考虑过多的回收问题，因为方法结束或线程结束时，内存自然随着回收；而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器就是主要收集这2个区域的内存；

## 怎么判断对象死了没有

* 在**堆**里面存放着几乎所有的对象，gc 就是要收集死了的对象的内存，所以对象死还是活也需要一个标准来限制，根据标准来产生算法。

### 引用计数算法

* 引用计数算法很简单：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加一，引用失效时就减一，当计数器为0时，则判定此对象不再被别的地方引用，可回收；

* 优点：实现简单，效率高，Python语言等还有其他就使用引用计数法进行内存管理，主流的Java虚拟机并不使用它；

* 缺点：引用计数法有一个致命的缺点，它很难解决对象之间相互引用导致内存泄漏的问题，在遍历时可能会发生这两个对象引数永远不为0，则永远不会被删除。举个例子就可以很好地说明：

  ~~~java
  public class MyObject{
    public Object instance = null;
    public static void testGC(){
    	MyObject a = new MyObject();
      MyObject b = new MyObject();
      a.instance = b;
      b.instance = a;
      //此时 b，a 的引用计数器都为2
      a = null;
      b = null;
      //此时 b，a 的引用计数器都为1
      //此时发生 GC，虽然我们想让 a,b 对象回收内存，可是此时它们的引用计数器都不为0，所以回收内存失败；（这里是假设虚拟机使用的是引用计数法的情况）
      System.gc();
    }
  }
  
  ~~~


### 可达性分析算法

* 既然Java虚拟机不用引用计数法，那么用什么呢？结果就是可达性算法；

* 基本思路：通过一系列称为“GC Root”的对象作为起始点，从这些结点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Root 没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达），则证明此对象是不可用的；

* 注意：JVM中并不是判断对象不可达就立即回收，**被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程**，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。

* 那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：

  (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

  (2). 方法区中的类静态属性引用的对象。

  (3). 方法区中常量引用的对象。

  (4). 本地方法栈中JNI(Native方法)引用的对象。

* 下面给出一个GCRoots的例子，如下图，为GCRoots的引用链。

  ![img](https://images2015.cnblogs.com/blog/249993/201703/249993-20170302205315766-1323892362.png)

* 对于可达性分析算法而言，未到达的对象并非是“非死不可”的，若要宣判一个对象死亡，至少需要经历两次标记阶段。

  1. 如果对象在进行可达性分析后发现没有与GCRoots相连的引用链，则该对象被第一次标记并进行一次筛选，筛选条件为是否有必要执行该对象的finalize方法，若对象没有覆盖finalize方法或者该finalize方法是否已经被虚拟机执行过了，则均视作不必要执行该对象的finalize方法，即该对象将会被回收。反之，若对象覆盖了finalize方法并且该finalize方法并没有被执行过，那么，这个对象会被放置在一个叫F-Queue的队列中，之后会由虚拟机自动建立的、优先级低的Finalizer线程去执行，而虚拟机不必要等待该线程执行结束，即虚拟机只负责建立线程，其他的事情交给此线程去处理。

  2. 对F-Queue中对象进行第二次标记，如果对象在finalize方法中拯救了自己，即关联上了GCRoots引用链，如把this关键字赋值给其他变量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除，如果对象还是没有拯救自己，那就会被回收。对象的finalize方法最多被虚拟机调用一次。即只能拯救自己一次；

## 四种引用状态

* 在JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次减弱。

* ![img](https://images2015.cnblogs.com/blog/249993/201703/249993-20170306195851516-1068507269.png)

  **1、强引用**

  代码中普遍存在的类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

  **2、软引用**

  描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。

  **3、弱引用**

  描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。

  **4、虚引用**

  这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。

## 回收方法区

* 在方法区中进行垃圾收集的"性价比"比较低，但是再小的蚊子也是肉，也需要收集；

* 方法区的垃圾回收主要回收两部分内容：1. 废弃常量。2. 无用的类。既然进行垃圾回收，就需要判断哪些是废弃常量，哪些是无用的类。

* 如何判断废弃常量呢？以字面量回收为例，如果一个字符串“abc”已经进入常量池，但是当前系统没有任何一个String对象引用了叫做“abc”的字面量，那么，如果发生垃圾回收并且有必要时，“abc”就会被系统移出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

* 如何判断无用的类呢？需要满足以下三个条件

  1. 该类的所有实例都已经被回收，即Java堆中不存在该类的任何实例。

  2. 加载该类的ClassLoader已经被回收。

  3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

  满足以上三个条件的类可以进行垃圾回收，但是并不是无用就被回收，虚拟机提供了一些参数供我们配置。需要时查询即可；

## 垃圾收集算法

* 终于到了这里，垃圾收集算法

###标记-清除（Mark-Sweep）算法

- 这是最基础的算法，标记-清除算法就如同它的名字样，分为“标记”和“清除”两个阶段：**首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。**

- 这种算法的不足主要体现在效率和空间，从效率的角度讲，标记和清除两个过程的效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。标记-清除算法执行过程如图：

![img](https://images2015.cnblogs.com/blog/249993/201703/249993-20170307205221484-1705867339.png)



###复制（Copying）算法

* 复制算法是为了解决效率问题而出现的，**它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉**。现在的商用虚拟机都采用这种算法来**回收新生代**，这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。复制算法的执行过程如图：

![img](https://images2015.cnblogs.com/blog/249993/201703/249993-20170307205837031-1503624197.png)

* 不过这种算法有个缺点，**内存缩小为了原来的一半，这样代价太高了**。现在的商用虚拟机都采用这种算法来**回收新生代**，不过研究表明1:1的比例非常不科学，因此**新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。**每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1，意思是每次新生代中可用内存空间为整个新生代容量的90%。当然，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。

###标记-整理（Mark-Compact）算法

* 复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。根据老年代的特点，有人提出了另外一种标记-整理算法，过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。标记-整理算法的工作过程如图：

![img](https://images2015.cnblogs.com/blog/249993/201703/249993-20170308200502734-920263398.png)



###分代收集算法

* 根据上面的内容，用一张图概括一下堆内存的布局

![img](https://images2015.cnblogs.com/blog/249993/201703/249993-20170308201424313-1417214713.png)

* 现代商用虚拟机基本都采用**分代收集算法**来进行垃圾回收。这种算法没什么特别的，无非是上面内容的结合罢了，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。





##Java内存分配和回收策略

* https://blog.csdn.net/dingji_ping/article/details/51008338

Java堆中各代分布
![img](https://img-blog.csdn.net/20160331201706716)

**Young**（年轻代）：主要是用来存放新生的对象。对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。

* 年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（用来表示内存首次分配的区域）和两个存活区（Survivor 0 、Survivor 1）。

* 绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；

* 当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1 是空白的，两个Survivor总有一个是空白的）；

* 此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；

* 当Survivor0 也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）;

* 当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。 
  　　 
  **Old**（年老代）：主要存放应用程序中生命周期长的内存对象。

* 对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC 后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　　

* 可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。 
  　　

* 如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold 来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。

* 可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。

  **Permanent**（永久代）：是指内存的永久保存区域,也就是方法区，主要存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域. 它和和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。

* 永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：

  * 类的所有实例都已经被回收；
  * 加载类的ClassLoader已经被回收；
  * 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）。
  * 永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制。 