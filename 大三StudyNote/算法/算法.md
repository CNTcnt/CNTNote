[TOC]

# 算法

## 查找算法

### 二分查找

* **二分查找**也称折半**查找**（Binary Search），它是一种效率较高的**查找**方法。 但是，折半**查找**要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

## 排序算法

### 冒泡排序

* 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

### 二分排序

* 分法插入排序，简称二分排序，是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left<right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。

### 快速排序

* 思想：随机找出一个数，可以随机取，也可以取固定位置，一般是取第一个或最后一个称为基准，然后就是比基准小的在左边，比基准大的放到右边，如何放做，就是和基准进行交换，这样交换完左边都是比基准小的，右边都是比较基准大的，这样就将一个数组分成了两个子数组，然后再按照同样的方法把子数组再分成更小的子数组，直到不能分解为止。
* 双指针法：我们现在准备将比基准数小的放在基准数左边，大的放右边；我们指定序列的第一个数为基准数，然后将2个指针一个指向头部，一个指向尾部，由于我们指定第一个数为基准数，所以尾部指针先动，寻找到比基准数小的数停下来，然后头部指针动寻找比基准数大的数停下来，然后交换双方所指向的数，然后继续循环，尾部指针动..................，然后等到双方相遇，则第一轮循环结束，将基准数与相遇位置的数交换。然后整个序列就分为了以基准数的位置为中心，分为左右两个序列，左序列小于基准数，有序列大于基准数。

### 选择排序

* **基本思想**：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。

### 插入排序

* **基本思想**：（这里先假定我们要的是从小到大的序列）从第一个元素开始，该元素可以认为已经被排序，然后开始取出下一个元素x，在已经排序的元素序列中从后向前扫描，如果第一次扫描就比元素x大，那么直接插入序列尾部即可，如果比元素x小，那么就继续从后往前扫描，直到找到一个数小于元素x，就插入到当时位置即可；

### 希尔排序

* 基本思想：设待排序元素序列有 n 个元素，然后取一个整数 gap < n 作为间隔，这样就将全部元素分为了 gap 个子序列，然后距离为 gap 的元素放在同一个子序列中，然后对每个子序列分别施行直接插入排序。然后缩小间隔 gap ,重复上诉操作，直至 gap == 1 时，将所有元素放在用一个序列中排序为止。这里可能会想：到最后还要对整个序列进行直接插入排序，那为什么不开始就直接插入排序，为什么要多此一举呢？其实，前面做的，开始，gap 的取值较大，每个子序列中元素少，排序很快，到后面 gap 的取值较小时，每个子序列中元素增多了起来，但由于前面工作的基础上，大部分元素已基本有序，所以排序顺度依然很快。 

### 堆排序算法

* 基本思想：初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个最大堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为最大堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立最大堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。










