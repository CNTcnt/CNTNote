[TOC]

# 设计模式6大准则

## 单一职责

* 单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。即一个类应该只负责一个职责，简单地来说，一个类中一个是一组相关性很高的函数，数据的封装。我有一个很直观的看法：如果我不能通过类名或函数名来判断它的功能，那么它就不是单一职责的；
* 如何划分一个类，一个函数的职责，每个人都有自己的看法，这需要根据个人经验，具体的业务逻辑而定；但是，有只要是遵守大致的指导原则即可，如 2 个完全不搭边的功能不应该放在一个类中；类中应该包含的是数据的封装，一组相关性很高的函数；

## 开闭原则

* 开闭原则：软件中的对象（类，模块，函数等）应该对于扩展是开放的，但是，对于修改是封闭的；

* 看了上面的定义是不是觉得云里雾里，我想了一下，我认为说的是：不应该通过修改原有代码来迭代扩展；那为什么不可以这样做呢？其实就是因为时间的推移，产品需要不断地升级维护扩展，如果你修改了原有代码就很可能会引发其他地问题，我们要确保原有软件地正确性，以及尽可能地少影响原有模块，就需要尽可能地遵守开闭原则；

* 实际开发中，其实修改原有代码，扩展代码是同时存在的，只能说，尽量遵守开闭原则即可；

* 那么，怎么通过不修改原有代码来迭代扩展呢？其实一个很实用的机制就是继承机制。程序一旦开发完成，程序中一个类的实现只应该因错误而被修改，新的或者改变的特性应该通过新建不同的类实现，新建的类可以通过继承的方式来重用原类的方法；

* 一个实用的方法，我们在编码时，我们应该把易变的业务模块抽象成抽象类 的 类方法，我们继承这个类覆写方法即可，然后调用类对象方法，策略模式或状态模式，适配器都很好的遵守了开闭原则；

* 举个例子

  ~~~java
  public class ImageLoader{
    ImageCache mImageCache;
    //给出扩展接口，扩展类只需继承 ImageCache 覆写方法即可扩展；而参数 ImageCache 对象则由外界给出，可以是任何继承于 ImageCache 的子类对象
    public void setImageCache(ImageCache cache){
    	mImageCache = cache;
    }
  }
  ~~~

* 小结：软件中的对象应该对于扩展是开放的，但是，对于修改是封闭的。而遵循开闭原则的重要手段应该是通过抽象；开闭原则知道我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现；

## 里氏替换原则

* 里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象；
* 里氏替换原则依赖于继承，多态这2个特性，简单的来说，就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会出任何错误或异常；其实总结起来就是：抽象
* 可以看开闭原则例子，我们向 ImageLoader 传 ImageCache 对象时，只要是继承于 ImageCache 的子类对象就可以，而 ImageLoader 根本就不关心是子类还是什么，只要能用就可以了；
* 里氏替换原则通过抽象建立规范，具体的实现在运行时替换掉抽线，保证系统的扩展性，灵活性。前面这个例子你应该看出来了，里氏替换原则和开闭原则往往是不离不弃的，合作共赢的，通过里氏替换来达到对扩展开放，对修改关闭的效果；这2个原则同时强调了一个 OOP 的重要特性——抽象，因此，运用抽象是走向代码优化的重要一步；

